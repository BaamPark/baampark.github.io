<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Smoothed Particle Hydrodynamics Simulation with CUDA | Baam&#39;s Techlog</title>
<meta name="keywords" content="OpenGL, CUDA">
<meta name="description" content="In this blog post, I will share my journey with my final project for my computer graphics course at school. Computer graphics is used to generate images, animations, and visual effects. You might see mechanical engineering students doing CAD (Computer-Aided Design) work — that’s also a form of computer graphics, though it focuses more on precision modeling and simulation for physical systems. OpenGL is is an API for rendering 2D and 3D vector graphics, commonly used by engineers and architects for CAD behind the hood.">
<meta name="author" content="">
<link rel="canonical" href="https://baampark.github.io/posts/2025-04-06_sph/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://baampark.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://baampark.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://baampark.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://baampark.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://baampark.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<meta property="og:title" content="Smoothed Particle Hydrodynamics Simulation with CUDA" />
<meta property="og:description" content="In this blog post, I will share my journey with my final project for my computer graphics course at school. Computer graphics is used to generate images, animations, and visual effects. You might see mechanical engineering students doing CAD (Computer-Aided Design) work — that’s also a form of computer graphics, though it focuses more on precision modeling and simulation for physical systems. OpenGL is is an API for rendering 2D and 3D vector graphics, commonly used by engineers and architects for CAD behind the hood." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://baampark.github.io/posts/2025-04-06_sph/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-04-06T15:04:51-05:00" />
<meta property="article:modified_time" content="2025-04-06T15:04:51-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Smoothed Particle Hydrodynamics Simulation with CUDA"/>
<meta name="twitter:description" content="In this blog post, I will share my journey with my final project for my computer graphics course at school. Computer graphics is used to generate images, animations, and visual effects. You might see mechanical engineering students doing CAD (Computer-Aided Design) work — that’s also a form of computer graphics, though it focuses more on precision modeling and simulation for physical systems. OpenGL is is an API for rendering 2D and 3D vector graphics, commonly used by engineers and architects for CAD behind the hood."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://baampark.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Smoothed Particle Hydrodynamics Simulation with CUDA",
      "item": "https://baampark.github.io/posts/2025-04-06_sph/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Smoothed Particle Hydrodynamics Simulation with CUDA",
  "name": "Smoothed Particle Hydrodynamics Simulation with CUDA",
  "description": "In this blog post, I will share my journey with my final project for my computer graphics course at school. Computer graphics is used to generate images, animations, and visual effects. You might see mechanical engineering students doing CAD (Computer-Aided Design) work — that’s also a form of computer graphics, though it focuses more on precision modeling and simulation for physical systems. OpenGL is is an API for rendering 2D and 3D vector graphics, commonly used by engineers and architects for CAD behind the hood.",
  "keywords": [
    "OpenGL", "CUDA"
  ],
  "articleBody": "\rIn this blog post, I will share my journey with my final project for my computer graphics course at school. Computer graphics is used to generate images, animations, and visual effects. You might see mechanical engineering students doing CAD (Computer-Aided Design) work — that’s also a form of computer graphics, though it focuses more on precision modeling and simulation for physical systems. OpenGL is is an API for rendering 2D and 3D vector graphics, commonly used by engineers and architects for CAD behind the hood. For my project, I implemented a basic 3D SPH system using OpenGL for real-time visualization. The simulation space is a cube filled with particles that respond to forces like pressure, viscosity, and external gravity. Each frame, the particle positions are updated based on SPH equations, and OpenGL renders the updated state, giving a dynamic and continuous fluid effect. However, SPH simulation is computationally expensive because it considers interactions between particles in a nested manner. I optimized the simulation using Compute Unified Device Architecture (CUDA). CUDA is an API developed by NVIDIA that is used for parallel computation on GPUs. I observed 98% performance improvement by adopting CUDA. Check my Github Repository for the code.\nSPH Simulation Workflow SPH is a particle-based method for simulating fluid dynamics by modeling fluids as discrete particles that carry properties like mass, velocity, and pressure. The simulation begins by computing the density at each particle based on its proximity to neighboring particles. Using the density, pressure is then calculated to capture how particles push against one another. These pressure values, along with other physical influences like viscosity and gravity, are used to compute forces acting on each particle. Finally, the simulation performs time integration to update particle velocities and positions, repeating this cycle continuously to simulate realistic fluid motion. Each particle in the SPH simulation carries five key attributes:\nPosition – the particle’s location in 3D space. Velocity – the speed and direction of the particle’s movement. Force – the net force acting on the particle, derived from pressure, viscosity, and external influences like gravity. Density – a measure of how much mass surrounds the particle, computed from nearby particles. Pressure – the internal pressure at the particle’s location, calculated from its density and used to simulate fluid behavior. Mathmatical background Algorithm Create particles arranged evenly in a 3D grid Find \\(\\mathcal{N}(p_i)\\) neighbors of each particle for each \\(p_i\\) in \\(P\\) do for each \\(\\mathcal{n_j}(p_i)\\) in \\(\\mathcal{N}(p_i)\\) Accumulate density Compute pressure using density Initialize total force \\(f_i=0\\) for each \\(\\mathcal{n_j}(p_i)\\) in \\(\\mathcal{N}(p_i)\\) Accumulate pressure force into \\(f_i\\) Accumulate viscosity force into \\(f_i\\) Add gravity force to \\(f_i\\) for each \\(p_i\\) in \\(P\\) do update velocity update position collision handling repeat 2 to 4 Density Computation The density \\(\\rho_i\\) at particle \\(i\\) is computed by summing contributions from neighboring particles \\(j\\): \\[\r\\rho_i = \\sum_j m_j W_{poly6}(r_{ij},h)\r\\] \\(m_j\\): mass of particle \\(j\\) \\(r_{ij}\\): distance between particles \\(i\\) and \\(j\\) \\(h\\): smoothing radius \\(W_{poly6}\\) kernel smoothing function \\[\rW_{\\text{poly6}}(r, h) =\r\\begin{cases}\r\\dfrac{315}{64 \\pi h^9}(h^2 - r^2)^3, \u0026 r \\leq h \\\\\r0, \u0026 r \u003e h\r\\end{cases}\r\\] Pressure Computation (Equation of State) The pressure \\(p_i\\) at particle \\(i\\) is determined from the density deviation using an equation of state: \\[p_i = k(\\rho_i - \\rho_0)\\] \\(k\\): Gas constant \\(\\rho_0\\): rest density Momentum Equation (Navier-Stokes Forces) For particle \\( i \\), the total force \\( \\mathbf{F}_i \\) includes pressure, viscosity, and gravity: \\[\r\\mathbf{F}_i = \\mathbf{F}_i^{\\text{pressure}} + \\mathbf{F}_i^{\\text{viscosity}} + \\mathbf{F}_i^{\\text{gravity}}\r\\] \\(\\mathbf{F}_i^{\\text{pressure}} = -\\sum_{j \\ne i} m \\frac{p_i + p_j}{2\\rho_j} \\nabla W_{\\text{spiky}}(\\mathbf{r}_{ij}, h)\\) \\(m\\): mass of particle \\(j\\) \\(p\\): pressure of a particle \\(\\nabla W_{\\text{spiky}}\\): Spiky Gradient \\[\r\\nabla W_{\\text{spiky}}(\\mathbf{r}, h) =\r\\begin{cases}\r-\\dfrac{45}{\\pi h^6}(h - r)^2 \\dfrac{r_{ij}}{r}, \u0026 0 \u003c r \\leq h \\\\\r0, \u0026 \\text{otherwise}\r\\end{cases}\r\\] \\(\\mathbf{F}_i^{\\text{viscosity}} = \\sum_{j \\ne i} \\mu m_j \\frac{\\mathbf{v}_j - \\mathbf{v}_i}{\\rho_j} \\nabla^2 W_{\\text{viscosity}}(\\mathbf{r}_{ij}, h)\\) \\(\\mu\\): viscosity coefficient \\(v\\): velocity Viscosity Laplacian \\( \\nabla^2 W_{\\text{viscosity}}\\) \\[\r\\nabla^2 W_{\\text{viscosity}}(r, h) =\r\\begin{cases}\r\\dfrac{45}{\\pi h^6}(h - r), \u0026 r \\leq h \\\\\r0, \u0026 r \u003e h\r\\end{cases}\r\\] \\(\\mathbf{F}_i^{\\text{gravity}} = \\rho_i \\mathbf{g}\\) \\(g\\): gravitational acceleration vector \\(\\rho\\): density Time Integration (Semi-implicit Euler) Acceleration \\(a_i = \\dfrac{F_i}{\\rho_i}\\) Velocity Update: \\(\\mathbf{v}^{new}_i = \\mathbf{v}^{old}_i + a_i \\Delta t\\) Position Update: \\(\\mathbf{x}^{new}_i = \\mathbf{x}^{old}_i + \\mathbf{v}^{new}_i \\Delta t\\) Collision Damping at Boundary If a particle hits a boundary, its velocity is modified to prevent it from escaping the simulation domain. Specifically, the velocity is scaled by a damping factor: \\[\\mathbf{v}^{new} = \\mathbf{v}^{old} \\times d\\] \\(\\mathbf{v}\\): velocity of a particle \\(d\\): damping factor Predefined Parameters for SPH simulation \\(k\\): gas constant \\(\\rho_0\\): rest density \\(m\\): mass of particle \\(\\mu\\): viscosity coefficient \\(g\\): gravity \\(\\Delta t\\): time step \\(h\\): smoothing radius \\(d\\): damping factor at collision Overshooting particles with a perfect symmetry In this section, we will see problems I first encountered when I asked chatgpt for the baseline simulation. Let’s take a look at the part of SPHSystem.cpp.\n// SPHParameters.h const float TIME_STEP = 0.005f; const float MASS = 10.0f; // kg const float SMOOTHING_RADIUS = 0.045f; const float GRAVITY = -9.81f; const float DAMPING = -0.3f; // SPHSystem.cpp void SPHSystem::initializeParticles() { for (int x = 0; x \u003c numX; ++x) { for (int y = 0; y \u003c numY; ++y) { for (int z = 0; z \u003c numZ; ++z) { glm::vec3 pos = glm::vec3( x * spacing, y * spacing + 0.5f, z * spacing ); particles.emplace_back(pos); } } } } void SPHSystem::integrate() { //Defines the simulation bounding box: all particles must stay within [0, 1] along x, y, and z const glm::vec3 boundsMin(0.0f, 0.0f, 0.0f); const glm::vec3 boundsMax(1.0f, 1.0f, 1.0f); for (auto\u0026 p : particles) { // Acceleration glm::vec3 acceleration = p.force / p.density; //Semi-implicit Euler p.velocity += acceleration * TIME_STEP; // velocity update p.position += p.velocity * TIME_STEP; // position update // Simple boundary constraint that particles stay within a defined simulation box for (int i = 0; i \u003c 3; ++i) { if (p.position[i] \u003c boundsMin[i]) { p.position[i] = boundsMin[i]; p.velocity[i] *= DAMPING; } else if (p.position[i] \u003e boundsMax[i]) { p.position[i] = boundsMax[i]; p.velocity[i] *= DAMPING; } } } } The initializeParticles function creates a 3D grid of particles arranged in a cubic grid structure. The cubic particles are located 0.5f high and start falling in the begining of simulation due to the gravity pull. When particles hit the bottom, they bounce upward with lower velocity. The below animation is rendered simulation.\nThe movements of particles were not I expected. Why particles oscillate without losing energy? This problem is called overshooting. Large updates to position and velocity can overshoot expected particle motion. Then, what parameter should we tweak to address overshooting? Time step \\(\\Delta t\\). Let’s lower the TIME_STEP to 0.0008 and run the simulating.\nNow we see the particles lose energy over time. But why it still doesn’t look like fluid? We need to break perfect symmetry. When particles are initialized in a perfectly uniform grid, they behave in unnaturally synchronized ways. Every particle experiences nearly identical forces from its neighbors. To make our simulation more physically plausible, we can introduce a small amount of random noise to the initial positions of particles.\nvoid SPHSystem::initializeParticles() { std::srand(static_cast\u003cunsigned\u003e(std::time(nullptr))); // Optional: seed RNG once float noiseScale = spacing * 0.1f; // 10% of spacing for (int x = 0; x \u003c numX; ++x) { for (int y = 0; y \u003c numY; ++y) { for (int z = 0; z \u003c numZ; ++z) { float nx = ((std::rand() % 1000) / 1000.0f - 0.5f) * noiseScale; float ny = ((std::rand() % 1000) / 1000.0f - 0.5f) * noiseScale; float nz = ((std::rand() % 1000) / 1000.0f - 0.5f) * noiseScale; glm::vec3 pos = glm::vec3( x * spacing + nx, y * spacing + 0.5f + ny, z * spacing + nz ); particles.emplace_back(pos); } } } } Unpredictable movements of particles make the simulation look more natural and fluid-like. Basic of CUDA It’s well known that multi-processing can optimize a program using parallization. Each core computes a separate chunk of the workload simultaneously, reducing overall execution time. If you have an fancy CPU, it might have 16 cores. This is nothing compared to GPUs. My GPU, RTX 3060 Ti, has has 4,864 CUDA cores. No matter what language you used, when your computer compiles your program, it will eventually translate it into assembly instructions. To run GPU-based program, it needs to be translated into an architecture that the NVIDIA GPU understands. The architecture is called CUDA (Compute Unified Device Architecture).\nCUDA consists of multiple streaming multiprocessors (SMs) bridged by global memory. Through the global memory, SM shares the resource. In each SM, there are multiple streaming processors (SPs) bridged by shared memory. A single thread is processed by SP. A group of thread is called a thread block, which is processed by SM. A kernel grid is the collection of thread blocks that are launched to execute a kernel function on the GPU.\nThe simiplest CUDA-parallization approach would be using global memory. However, it can be further opimized if you use shared memory. Shared memory has much lower latency and higher bandwidth compared to global memory. Of course, there is trade-off. Shared memory has much less capacity. This means you have to divide your data into smaller chunks and carefully load only the necessary portions into shared memory.\nThe below image compares global memory and shared memory approaches for matrix multiplication in CUDA. The shared memory appraoch is also called a tiling technique, which divide data into smaller chunk.\nOptimize SPH Algorithm using CUDA In this section, we will optimize the SPH algorithm using CUDA global functions. Let’s take a look at SPHSystem.h to see scaffold of the data structure.\nclass SPHSystem { public: std::vector\u003cParticle\u003e particles; SPHSystem(); ~SPHSystem(); void computeDensityPressure(); void computeForces(); void integrate(); private: void initializeParticles(); }; The first step we will optimize the computeDensityPressure function. When launching a global kernel in CUDA, you must specify number of blocks and number of threads per block besides the arguments. kernel\u003c\u003c\u003e\u003e();. There is a folmula for number of blocks given the size of your data. int blocks = (size + threadsPerBlock - 1) / threadsPerBlock; In our case, the size is the number of particles.\ninline dim3 gridFor(int N,int block){ return dim3((N+block-1)/block); } void SPHSystemCUDA::computeDensityPressure(){ densityPressureKernel\u003c\u003c\u003cgridFor(N_,256),256\u003e\u003e\u003e(N_,d_pos_,d_density_,d_pressure_); cudaDeviceSynchronize(); } The computeDensityPressure function will call global kernel densityPressureKernel. In addition to the global function, I provide CPU-based function for comparison. First thing we notice is densityPressureKernel takes arguments while CPU-based function doesn’t. Second, the global kernel is O(n) while the other one is O(n^2). I first answer the second question. Let’s say we have 100 particles. In the CPU-based function, the program iterates over each particle sequentially. In the CUDA global version, each thread is responsible for handling a single particle, identified by its thread id. Now let’s answer the first question.\nIn global kernel, we cannot access particle directly because CUDA only supports low-level C++ objects like float or float3. So we need containers for particle.position, particle.density, and particle.pressure. The three array arguments, pos, dens, and pres are stored in global memory, where all threads can access them.\n__global__ void densityPressureKernel( int N, const float3* pos, float* dens, float* pres) { int id = blockIdx.x*blockDim.x + threadIdx.x; if (id\u003e=N) return; float density = 0.f; float3 pi = pos[id]; for (int j=0; j\u003cN; ++j) { float3 rij{ pos[j].x - pi.x, pos[j].y - pi.y, pos[j].z - pi.z}; float r2 = rij.x*rij.x + rij.y*rij.y + rij.z*rij.z; density += MASS * poly6Kernel(r2, SMOOTHING_RADIUS); } dens[id] = density; pres[id] = GAS_CONSTANT * (density - REST_DENSITY); } // ↑ GPU-based function // │ // │ // │ // ↓ CPU-based function void SPHSystem::computeDensityPressure() { for (auto\u0026 pi : particles) { pi.density = 0.0f; for (const auto\u0026 pj : particles) { glm::vec3 rij = pj.position - pi.position; float r2 = glm::dot(rij, rij); pi.density += MASS * poly6Kernel(r2, SMOOTHING_RADIUS); } pi.pressure = GAS_CONSTANT * (pi.density - REST_DENSITY); } } We are gonna skip computeForces function and jump to integrate function. We see CUDA function cudaMemcpy. In CUDA code, if variable starts with h like h_pos, it means that the data resides on host (CPU). If variable starts with d, it means the data is on device (GPU). In the below code, cudaMemcpy moves data from host to device. Lastly, we update particles with h_pos transfered from GPU to CPU.\nvoid SPHSystemCUDA::integrate(){ integrateKernel\u003c\u003c\u003cgridFor(N_,256),256\u003e\u003e\u003e(N_,d_pos_,d_vel_,d_force_,d_density_); cudaDeviceSynchronize(); // copy positions back so ParticleRenderer can update VBO std::vector\u003cfloat3\u003e h_pos(N_); cudaMemcpy(h_pos.data(), d_pos_, N_*sizeof(float3), cudaMemcpyDeviceToHost); for (int i=0;i\u003cN_;++i){ particles[i].position = glm::vec3(h_pos[i].x,h_pos[i].y,h_pos[i].z); } } Check my code for details about the CUDA script. You can see how fast the CUDA SPH simulation runs.\nApproach # Particles Total Time (sec) CPU 125 4.161 CUDA 125 1.471 CPU 1,000 169.067 CUDA 1,000 1.742 ",
  "wordCount" : "2119",
  "inLanguage": "en",
  "datePublished": "2025-04-06T15:04:51-05:00",
  "dateModified": "2025-04-06T15:04:51-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://baampark.github.io/posts/2025-04-06_sph/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Baam's Techlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://baampark.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://baampark.github.io/" accesskey="h" title="Baam&#39;s Techlog (Alt + H)">Baam&#39;s Techlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://baampark.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://baampark.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Smoothed Particle Hydrodynamics Simulation with CUDA
    </h1>
    <div class="post-meta"><span title='2025-04-06 15:04:51 -0500 -0500'>April 6, 2025</span>

</div>
  </header> 
  <div class="post-content"><p><img loading="lazy" src="/images/2025-04-06_SPH/sph_cuda.gif" alt="cover"  />

In this blog post, I will share my journey with my final project for my computer graphics course at school. Computer graphics is used to generate images, animations, and visual effects. You might see mechanical engineering students doing CAD (Computer-Aided Design) work — that’s also a form of computer graphics, though it focuses more on precision modeling and simulation for physical systems. OpenGL is is an API for rendering 2D and 3D vector graphics, commonly used by engineers and architects for CAD behind the hood. For my project, I implemented a basic 3D SPH system using OpenGL for real-time visualization. The simulation space is a cube filled with particles that respond to forces like pressure, viscosity, and external gravity. Each frame, the particle positions are updated based on SPH equations, and OpenGL renders the updated state, giving a dynamic and continuous fluid effect. However, SPH simulation is computationally expensive because it considers interactions between particles in a nested manner. I optimized the simulation using Compute Unified Device Architecture (CUDA). CUDA is an API developed by NVIDIA that is used for parallel computation on GPUs. I observed 98% performance improvement by adopting CUDA. Check my <a href="https://github.com/BaamPark/FluidSimulationWithCUDA">Github Repository</a> for the code.</p>
<h2 id="sph-simulation-workflow">SPH Simulation Workflow<a hidden class="anchor" aria-hidden="true" href="#sph-simulation-workflow">#</a></h2>
<p><img loading="lazy" src="/images/2025-04-06_SPH/SPH_pipeline.png" alt="SPH Pipeline"  />

SPH is a particle-based method for simulating fluid dynamics by modeling fluids as discrete particles that carry properties like mass, velocity, and pressure. The simulation begins by computing the density at each particle based on its proximity to neighboring particles. Using the density, pressure is then calculated to capture how particles push against one another. These pressure values, along with other physical influences like viscosity and gravity, are used to compute forces acting on each particle. Finally, the simulation performs time integration to update particle velocities and positions, repeating this cycle continuously to simulate realistic fluid motion. Each particle in the SPH simulation carries five key attributes:</p>
<ol>
<li>Position – the particle’s location in 3D space.</li>
<li>Velocity – the speed and direction of the particle’s movement.</li>
<li>Force – the net force acting on the particle, derived from pressure, viscosity, and external influences like gravity.</li>
<li>Density – a measure of how much mass surrounds the particle, computed from nearby particles.</li>
<li>Pressure – the internal pressure at the particle’s location, calculated from its density and used to simulate fluid behavior.</li>
</ol>
<h2 id="mathmatical-background">Mathmatical background<a hidden class="anchor" aria-hidden="true" href="#mathmatical-background">#</a></h2>
<h3 id="algorithm">Algorithm<a hidden class="anchor" aria-hidden="true" href="#algorithm">#</a></h3>
<ol>
<li>Create particles arranged evenly in a 3D grid</li>
<li>Find \(\mathcal{N}(p_i)\) neighbors of each particle</li>
<li>for each \(p_i\) in \(P\) do
<ul>
<li>for each \(\mathcal{n_j}(p_i)\) in \(\mathcal{N}(p_i)\)
<ul>
<li>Accumulate density</li>
</ul>
</li>
<li>Compute pressure using density</li>
<li>Initialize total force \(f_i=0\)</li>
<li>for each \(\mathcal{n_j}(p_i)\) in \(\mathcal{N}(p_i)\)
<ul>
<li>Accumulate pressure force into \(f_i\)</li>
<li>Accumulate viscosity force into \(f_i\)</li>
</ul>
</li>
<li>Add gravity force to \(f_i\)</li>
</ul>
</li>
<li>for each \(p_i\) in \(P\) do
<ul>
<li>update velocity</li>
<li>update position</li>
<li>collision handling</li>
</ul>
</li>
<li>repeat 2 to 4</li>
</ol>
<h3 id="density-computation">Density Computation<a hidden class="anchor" aria-hidden="true" href="#density-computation">#</a></h3>
<p>The density \(\rho_i\) at particle \(i\) is computed by summing contributions from neighboring particles \(j\):
</p>
\[
    \rho_i = \sum_j m_j W_{poly6}(r_{ij},h)
    \]
<ul>
<li>\(m_j\): mass of particle \(j\)</li>
<li>\(r_{ij}\): distance between particles \(i\) and \(j\)</li>
<li>\(h\): smoothing radius</li>
<li>\(W_{poly6}\) kernel smoothing function
\[
W_{\text{poly6}}(r, h) =
\begin{cases}
\dfrac{315}{64 \pi h^9}(h^2 - r^2)^3, & r \leq h \\
0, & r > h
\end{cases}
\]</li>
</ul>
<h3 id="pressure-computation-equation-of-state">Pressure Computation (Equation of State)<a hidden class="anchor" aria-hidden="true" href="#pressure-computation-equation-of-state">#</a></h3>
<p>The pressure \(p_i\) at particle \(i\) is determined from the density deviation using an equation of state:
</p>
\[p_i = k(\rho_i - \rho_0)\]
<ul>
<li>\(k\): Gas constant</li>
<li>\(\rho_0\): rest density</li>
</ul>
<h3 id="momentum-equation-navier-stokes-forces">Momentum Equation (Navier-Stokes Forces)<a hidden class="anchor" aria-hidden="true" href="#momentum-equation-navier-stokes-forces">#</a></h3>
<p>For particle \( i \), the total force \( \mathbf{F}_i \) includes pressure, viscosity, and gravity:
</p>
\[
\mathbf{F}_i = \mathbf{F}_i^{\text{pressure}} + \mathbf{F}_i^{\text{viscosity}} + \mathbf{F}_i^{\text{gravity}}
\]
<ul>
<li>\(\mathbf{F}_i^{\text{pressure}} = -\sum_{j \ne i} m \frac{p_i + p_j}{2\rho_j} \nabla W_{\text{spiky}}(\mathbf{r}_{ij}, h)\)
<ul>
<li>\(m\): mass of particle \(j\)</li>
<li>\(p\): pressure of a particle</li>
<li>\(\nabla W_{\text{spiky}}\): Spiky Gradient
\[
        \nabla W_{\text{spiky}}(\mathbf{r}, h) =
        \begin{cases}
        -\dfrac{45}{\pi h^6}(h - r)^2 \dfrac{r_{ij}}{r}, & 0 < r \leq h \\
        0, & \text{otherwise}
        \end{cases}
        \]</li>
</ul>
</li>
<li>\(\mathbf{F}_i^{\text{viscosity}} = \sum_{j \ne i} \mu m_j \frac{\mathbf{v}_j - \mathbf{v}_i}{\rho_j} \nabla^2 W_{\text{viscosity}}(\mathbf{r}_{ij}, h)\)
<ul>
<li>\(\mu\): viscosity coefficient</li>
<li>\(v\): velocity</li>
<li>Viscosity Laplacian \( \nabla^2 W_{\text{viscosity}}\)
\[
        \nabla^2 W_{\text{viscosity}}(r, h) =
        \begin{cases}
        \dfrac{45}{\pi h^6}(h - r), & r \leq h \\
        0, & r > h
        \end{cases}
        \]</li>
</ul>
</li>
<li>\(\mathbf{F}_i^{\text{gravity}} = \rho_i \mathbf{g}\)
<ul>
<li>\(g\): gravitational acceleration vector</li>
<li>\(\rho\): density</li>
</ul>
</li>
</ul>
<h3 id="time-integration-semi-implicit-euler">Time Integration (Semi-implicit Euler)<a hidden class="anchor" aria-hidden="true" href="#time-integration-semi-implicit-euler">#</a></h3>
<ul>
<li>Acceleration \(a_i = \dfrac{F_i}{\rho_i}\)</li>
<li>Velocity Update: \(\mathbf{v}^{new}_i = \mathbf{v}^{old}_i + a_i \Delta t\)</li>
<li>Position Update: \(\mathbf{x}^{new}_i = \mathbf{x}^{old}_i + \mathbf{v}^{new}_i \Delta t\)</li>
</ul>
<h3 id="collision-damping-at-boundary">Collision Damping at Boundary<a hidden class="anchor" aria-hidden="true" href="#collision-damping-at-boundary">#</a></h3>
<p>If a particle hits a boundary, its velocity is modified to prevent it from escaping the simulation domain. Specifically, the velocity is scaled by a damping factor:
</p>
\[\mathbf{v}^{new} = \mathbf{v}^{old} \times d\]
<ul>
<li>\(\mathbf{v}\): velocity of a particle</li>
<li>\(d\): damping factor</li>
</ul>
<h3 id="predefined-parameters-for-sph-simulation">Predefined Parameters for SPH simulation<a hidden class="anchor" aria-hidden="true" href="#predefined-parameters-for-sph-simulation">#</a></h3>
<ul>
<li>\(k\): gas constant</li>
<li>\(\rho_0\): rest density</li>
<li>\(m\): mass of particle</li>
<li>\(\mu\): viscosity coefficient</li>
<li>\(g\): gravity</li>
<li>\(\Delta t\): time step</li>
<li>\(h\): smoothing radius</li>
<li>\(d\): damping factor at collision</li>
</ul>
<h2 id="overshooting-particles-with-a-perfect-symmetry">Overshooting particles with a perfect symmetry<a hidden class="anchor" aria-hidden="true" href="#overshooting-particles-with-a-perfect-symmetry">#</a></h2>
<p>In this section, we will see problems I first encountered when I asked chatgpt for the baseline simulation. Let&rsquo;s take a look at the part of <code>SPHSystem.cpp</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// SPHParameters.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> TIME_STEP <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.005f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> MASS <span style="color:#f92672">=</span> <span style="color:#ae81ff">10.0f</span>; <span style="color:#75715e">// kg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> SMOOTHING_RADIUS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.045f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> GRAVITY <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">9.81f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> DAMPING <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.3f</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SPHSystem.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> SPHSystem<span style="color:#f92672">::</span>initializeParticles() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> numX; <span style="color:#f92672">++</span>x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; y <span style="color:#f92672">&lt;</span> numY; <span style="color:#f92672">++</span>y) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; z <span style="color:#f92672">&lt;</span> numZ; <span style="color:#f92672">++</span>z) {
</span></span><span style="display:flex;"><span>                glm<span style="color:#f92672">::</span>vec3 pos <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>vec3(
</span></span><span style="display:flex;"><span>                    x <span style="color:#f92672">*</span> spacing,
</span></span><span style="display:flex;"><span>                    y <span style="color:#f92672">*</span> spacing <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5f</span>,
</span></span><span style="display:flex;"><span>                    z <span style="color:#f92672">*</span> spacing
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>                particles.emplace_back(pos);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> SPHSystem<span style="color:#f92672">::</span>integrate() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Defines the simulation bounding box: all particles must stay within [0, 1] along x, y, and z
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> glm<span style="color:#f92672">::</span>vec3 boundsMin(<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> glm<span style="color:#f92672">::</span>vec3 boundsMax(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> p : particles) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Acceleration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        glm<span style="color:#f92672">::</span>vec3 acceleration <span style="color:#f92672">=</span> p.force <span style="color:#f92672">/</span> p.density;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Semi-implicit Euler
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p.velocity <span style="color:#f92672">+=</span> acceleration <span style="color:#f92672">*</span> TIME_STEP; <span style="color:#75715e">// velocity update
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p.position <span style="color:#f92672">+=</span> p.velocity <span style="color:#f92672">*</span> TIME_STEP; <span style="color:#75715e">// position update
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Simple boundary constraint that particles stay within a defined simulation box
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p.position[i] <span style="color:#f92672">&lt;</span> boundsMin[i]) {
</span></span><span style="display:flex;"><span>                p.position[i] <span style="color:#f92672">=</span> boundsMin[i];
</span></span><span style="display:flex;"><span>                p.velocity[i] <span style="color:#f92672">*=</span> DAMPING;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (p.position[i] <span style="color:#f92672">&gt;</span> boundsMax[i]) {
</span></span><span style="display:flex;"><span>                p.position[i] <span style="color:#f92672">=</span> boundsMax[i];
</span></span><span style="display:flex;"><span>                p.velocity[i] <span style="color:#f92672">*=</span> DAMPING;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>initializeParticles</code> function creates a 3D grid of particles arranged in a cubic grid structure. The cubic particles are located <code>0.5f</code> high and start falling in the begining of simulation due to the gravity pull. When particles hit the bottom, they bounce upward with lower velocity. The below animation is rendered simulation.</p>
<p><img loading="lazy" src="/images/2025-04-06_SPH/sph_high_timeStep.gif" alt="SPH_high_timeStemp"  />
</p>
<p>The movements of particles were not I expected. Why particles oscillate without losing energy? This problem is called <code>overshooting</code>. Large updates to position and velocity can overshoot expected particle motion. Then, what parameter should we tweak to address overshooting? <strong>Time step \(\Delta t\)</strong>. Let&rsquo;s lower the <code>TIME_STEP</code> to 0.0008 and run the simulating.</p>
<p><img loading="lazy" src="/images/2025-04-06_SPH/sph_low_timeStep.gif" alt="SPH_high_timeStemp"  />
</p>
<p>Now we see the particles lose energy over time. But why it still doesn&rsquo;t look like fluid? We need to break perfect symmetry. When particles are initialized in a perfectly uniform grid, they behave in unnaturally synchronized ways. Every particle experiences nearly identical forces from its neighbors. To make our simulation more physically plausible, we can introduce a small amount of random noise to the initial positions of particles.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> SPHSystem<span style="color:#f92672">::</span>initializeParticles() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>srand(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span><span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>time(<span style="color:#66d9ef">nullptr</span>))); <span style="color:#75715e">// Optional: seed RNG once
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> noiseScale <span style="color:#f92672">=</span> spacing <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1f</span>; <span style="color:#75715e">// 10% of spacing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> numX; <span style="color:#f92672">++</span>x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; y <span style="color:#f92672">&lt;</span> numY; <span style="color:#f92672">++</span>y) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; z <span style="color:#f92672">&lt;</span> numZ; <span style="color:#f92672">++</span>z) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> nx <span style="color:#f92672">=</span> ((std<span style="color:#f92672">::</span>rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">1000</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000.0f</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> noiseScale;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> ny <span style="color:#f92672">=</span> ((std<span style="color:#f92672">::</span>rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">1000</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000.0f</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> noiseScale;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> nz <span style="color:#f92672">=</span> ((std<span style="color:#f92672">::</span>rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">1000</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000.0f</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> noiseScale;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                glm<span style="color:#f92672">::</span>vec3 pos <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>vec3(
</span></span><span style="display:flex;"><span>                    x <span style="color:#f92672">*</span> spacing <span style="color:#f92672">+</span> nx,
</span></span><span style="display:flex;"><span>                    y <span style="color:#f92672">*</span> spacing <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5f</span> <span style="color:#f92672">+</span> ny,
</span></span><span style="display:flex;"><span>                    z <span style="color:#f92672">*</span> spacing <span style="color:#f92672">+</span> nz
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>                particles.emplace_back(pos);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unpredictable movements of particles make the simulation look more natural and fluid-like.
<img loading="lazy" src="/images/2025-04-06_SPH/sph_low_timeStep_random.gif" alt="SPH_high_timeStemp"  />
</p>
<h2 id="basic-of-cuda">Basic of CUDA<a hidden class="anchor" aria-hidden="true" href="#basic-of-cuda">#</a></h2>
<p>It&rsquo;s well known that multi-processing can optimize a program using parallization. Each core computes a separate chunk of the workload simultaneously, reducing overall execution time. If you have an fancy CPU, it might have 16 cores. This is nothing compared to GPUs. My GPU, RTX 3060 Ti, has has 4,864 CUDA cores. No matter what language you used, when your computer compiles your program, it will eventually translate it into assembly instructions. To run GPU-based program, it needs to be translated into an architecture that the NVIDIA GPU understands. The architecture is called CUDA (Compute Unified Device Architecture).</p>
<p><img loading="lazy" src="/images/2025-04-06_SPH/CUDA_architecture.png" alt="CUDA_architecture"  />
</p>
<p>CUDA consists of multiple streaming multiprocessors (SMs) bridged by global memory. Through the <strong>global memory</strong>, SM shares the resource. In each SM, there are multiple streaming processors (SPs) bridged by <strong>shared memory</strong>. A single thread is processed by SP. A group of thread is called a thread block, which is processed by SM. A kernel grid is the collection of thread blocks that are launched to execute a kernel function on the GPU.</p>
<p>The simiplest CUDA-parallization approach would be using global memory. However, it can be further opimized if you use shared memory. Shared memory has much lower latency and higher bandwidth compared to global memory. Of course, there is trade-off. Shared memory has much less capacity. This means you have to divide your data into smaller chunks and carefully load only the necessary portions into shared memory.</p>
<p>The below image compares global memory and shared memory approaches for matrix multiplication in CUDA. The shared memory appraoch is also called a tiling technique, which divide data into smaller chunk.</p>
<p><img loading="lazy" src="/images/2025-04-06_SPH/global_vs_shared.png" alt="CUDA_architecture"  />
</p>
<h2 id="optimize-sph-algorithm-using-cuda">Optimize SPH Algorithm using CUDA<a hidden class="anchor" aria-hidden="true" href="#optimize-sph-algorithm-using-cuda">#</a></h2>
<p>In this section, we will optimize the SPH algorithm using CUDA global functions. Let&rsquo;s take a look at <code>SPHSystem.h</code> to see scaffold of the data structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SPHSystem</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Particle<span style="color:#f92672">&gt;</span> particles;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SPHSystem();
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>SPHSystem();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">computeDensityPressure</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">computeForces</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">integrate</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> initializeParticles();
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The first step we will optimize the <code>computeDensityPressure</code> function. When launching a global kernel in CUDA, you must specify number of blocks and number of threads per block besides the arguments. <code>kernel&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;();</code>. There is a folmula for number of blocks given the size of your data. <code>int blocks = (size + threadsPerBlock - 1) / threadsPerBlock;</code> In our case, the size is the number of particles.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> dim3 <span style="color:#a6e22e">gridFor</span>(<span style="color:#66d9ef">int</span> N,<span style="color:#66d9ef">int</span> block){ <span style="color:#66d9ef">return</span> dim3((N<span style="color:#f92672">+</span>block<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span>block); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> SPHSystemCUDA<span style="color:#f92672">::</span>computeDensityPressure(){
</span></span><span style="display:flex;"><span>    densityPressureKernel<span style="color:#f92672">&lt;&lt;&lt;</span>gridFor(N_,<span style="color:#ae81ff">256</span>),<span style="color:#ae81ff">256</span><span style="color:#f92672">&gt;&gt;&gt;</span>(N_,d_pos_,d_density_,d_pressure_);
</span></span><span style="display:flex;"><span>    cudaDeviceSynchronize();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>computeDensityPressure</code> function will call global kernel <code>densityPressureKernel</code>. In addition to the global function, I provide CPU-based function for comparison. First thing we notice is <code>densityPressureKernel</code> takes arguments while CPU-based function doesn&rsquo;t. Second, the global kernel is O(n) while the other one is O(n^2). I first answer the second question. Let&rsquo;s say we have 100 particles. In the CPU-based function, the program iterates over each particle sequentially. In the CUDA global version, each thread is responsible for handling a single particle, identified by its thread <code>id</code>. Now let&rsquo;s answer the first question.</p>
<p>In global kernel, we cannot access particle directly because CUDA only supports low-level C++ objects like <code>float</code> or <code>float3</code>. So we need containers for <code>particle.position</code>, <code>particle.density</code>, and <code>particle.pressure</code>. The three array arguments, <code>pos</code>, <code>dens</code>, and <code>pres</code> are stored in global memory, where all threads can access them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__global__ <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">densityPressureKernel</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> N, <span style="color:#66d9ef">const</span> float3<span style="color:#f92672">*</span> pos, <span style="color:#66d9ef">float</span><span style="color:#f92672">*</span> dens, <span style="color:#66d9ef">float</span><span style="color:#f92672">*</span> pres)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> blockIdx.x<span style="color:#f92672">*</span>blockDim.x <span style="color:#f92672">+</span> threadIdx.x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (id<span style="color:#f92672">&gt;=</span>N) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> density <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.f</span>;
</span></span><span style="display:flex;"><span>    float3 pi <span style="color:#f92672">=</span> pos[id];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>        float3 rij{
</span></span><span style="display:flex;"><span>            pos[j].x <span style="color:#f92672">-</span> pi.x,
</span></span><span style="display:flex;"><span>            pos[j].y <span style="color:#f92672">-</span> pi.y,
</span></span><span style="display:flex;"><span>            pos[j].z <span style="color:#f92672">-</span> pi.z};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> r2 <span style="color:#f92672">=</span> rij.x<span style="color:#f92672">*</span>rij.x <span style="color:#f92672">+</span> rij.y<span style="color:#f92672">*</span>rij.y <span style="color:#f92672">+</span> rij.z<span style="color:#f92672">*</span>rij.z;
</span></span><span style="display:flex;"><span>        density <span style="color:#f92672">+=</span> MASS <span style="color:#f92672">*</span> poly6Kernel(r2, SMOOTHING_RADIUS);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dens[id] <span style="color:#f92672">=</span> density;
</span></span><span style="display:flex;"><span>    pres[id] <span style="color:#f92672">=</span> GAS_CONSTANT <span style="color:#f92672">*</span> (density <span style="color:#f92672">-</span> REST_DENSITY);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    ↑ GPU-based function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    │
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    │
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    │
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    ↓ CPU-based function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> SPHSystem<span style="color:#f92672">::</span>computeDensityPressure() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> pi : particles) {
</span></span><span style="display:flex;"><span>        pi.density <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0f</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> pj : particles) {
</span></span><span style="display:flex;"><span>            glm<span style="color:#f92672">::</span>vec3 rij <span style="color:#f92672">=</span> pj.position <span style="color:#f92672">-</span> pi.position;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float</span> r2 <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>dot(rij, rij);
</span></span><span style="display:flex;"><span>            pi.density <span style="color:#f92672">+=</span> MASS <span style="color:#f92672">*</span> poly6Kernel(r2, SMOOTHING_RADIUS);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pi.pressure <span style="color:#f92672">=</span> GAS_CONSTANT <span style="color:#f92672">*</span> (pi.density <span style="color:#f92672">-</span> REST_DENSITY);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We are gonna skip <code>computeForces</code> function and jump to <code>integrate</code> function. We see CUDA function <code>cudaMemcpy</code>. In CUDA code, if variable starts with <code>h</code> like <code>h_pos</code>, it means that the data resides on host (CPU). If variable starts with <code>d</code>, it means the data is on device (GPU). In the below code, <code>cudaMemcpy</code> moves data from host to device. Lastly, we update <code>particles</code> with <code>h_pos</code> transfered from GPU to CPU.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> SPHSystemCUDA<span style="color:#f92672">::</span>integrate(){
</span></span><span style="display:flex;"><span>    integrateKernel<span style="color:#f92672">&lt;&lt;&lt;</span>gridFor(N_,<span style="color:#ae81ff">256</span>),<span style="color:#ae81ff">256</span><span style="color:#f92672">&gt;&gt;&gt;</span>(N_,d_pos_,d_vel_,d_force_,d_density_);
</span></span><span style="display:flex;"><span>    cudaDeviceSynchronize();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// copy positions back so ParticleRenderer can update VBO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>float3<span style="color:#f92672">&gt;</span> h_pos(N_);
</span></span><span style="display:flex;"><span>    cudaMemcpy(h_pos.data(), d_pos_, N_<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(float3), cudaMemcpyDeviceToHost);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>N_;<span style="color:#f92672">++</span>i){
</span></span><span style="display:flex;"><span>        particles[i].position <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>vec3(h_pos[i].x,h_pos[i].y,h_pos[i].z);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Check my <a href="https://github.com/BaamPark/FluidSimulationWithCUDA/blob/main/SPHSytemSharedCUDA.cu">code</a> for details about the CUDA script. You can see how fast the CUDA SPH simulation runs.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Approach</th>
<th style="text-align:left"># Particles</th>
<th style="text-align:left">Total Time (sec)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CPU</td>
<td style="text-align:left">125</td>
<td style="text-align:left">4.161</td>
</tr>
<tr>
<td style="text-align:left"><strong>CUDA</strong></td>
<td style="text-align:left"><strong>125</strong></td>
<td style="text-align:left"><strong>1.471</strong></td>
</tr>
<tr>
<td style="text-align:left">CPU</td>
<td style="text-align:left">1,000</td>
<td style="text-align:left">169.067</td>
</tr>
<tr>
<td style="text-align:left"><strong>CUDA</strong></td>
<td style="text-align:left"><strong>1,000</strong></td>
<td style="text-align:left"><strong>1.742</strong></td>
</tr>
</tbody>
</table>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://baampark.github.io/tags/opengl/">OpenGL</a></li>
      <li><a href="https://baampark.github.io/tags/cuda/">CUDA</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://baampark.github.io/">Baam&#39;s Techlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
